<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TRANSMISSION CONTROL PROTOCOL</title>
</head>
<body>
<h1>TRANSMISSION CONTROL PROTOCOL</h1><br><br>Before you read, I highly recommend just going through the book yourself. It is highly digestable, even with little networking knowledge.<br> <br><h2>Operations</h2><br><br>Basic Data Transfer<li>TCP is able to transfer a continuous stream of octets bth directions by packaging some octets into segments</li><li>TCPs decided when to block or forward data </li><br><br>Reliablility<li>TCP must recover from data that is damaged, lost, duplicated, or delivered out of order</li><li>each octet is assigned a sequence number and requires a postitive acknowledgement (ACK)</li><li>If ACK is not received within timeout, data is retransmitted</li><li>sequence number is used at the receiver to reorganize the packets</li><li>checksum is used to verify the packet integrity</li><br><br>Flow Control<li>managed by receiver who returns a "window" with every ACK. The window indicates the number of octets that the sender may transmit before requiring permission</li><br><br>Multiplexing<li>allows for many processes within a single host to use TCP communication facilities simultaneously; TCp provides a set of addresses or ports. Network + Host address = Socket which ID's the connection</li><li>binding of ports to processes is handled by each host</li><br><br>Connections<li>in order to maintain flow control and reliability, the TCP but initialize status information for each data stream</li><li>to communicate, two processes's TTCP's must establish a connection. When communication is closed or canceled, the resources must be freed</li><br><br>Precedence and Security<li>dependant on the users</li><li>default values used if not requsted</li><br><br><h2>PHILOSOPHY</h2><br><br>Model of Operation<li>processes call TCP and pass buffers of data as arguments</li><li>TCP packages the data into segments and calls on the internet module to transmit to the destination TCP</li><li>recieving TCP decapsulates the segment and places the data into the receiving user's buffer</li><br><br>The Internet Module<li>packages the TCP segments inside of an internet datagram and routes it to the destiation via internet module/intermediate gateway</li><li>if local, the datagram is embedded in a local network packet</li><br><br>Gateways<li>at gateways, the datagram can become "unwrapped" from it's local packet to determine which network it needs to travel next, and "re-wrapped" with a local packet suitable to the next network</li><li>gateways can also break up an internet datagram into smaller fragments (the grateway produces a set of internet datagrams, each carry a fragment of the original datagram)</li><li>this process can be done multiple times</li><br><br>Destination Internet Module<li>unwraps the segment from the datagram (after reassembiling the fragments if necessary) and passes it to the destination TCP</li><br><br>The Host Environment<li>assumed to be in a module in an OS, controlled by a device driver module which the TCP indirectly calls when calling on the internet datagram protocol module</li><br><br>Relations to Other Protocols<li>the TCP in the protocol hierarchy</li><br><pre><br> +------+ +-----+ +-----+       +-----+<br> |Telnet| | FTP | |Voice|  ...  |     |  Application Level<br> +------+ +-----+ +-----+       +-----+<br>       |   |         |             |<br>      +-----+     +-----+       +-----+<br>      | TCP |     | RTP |  ...  |     |  Host Level<br>      +-----+     +-----+       +-----+<br>         |           |             |<br>      +-------------------------------+<br>      |    Internet Protocol & ICMP   |  Gateway Level<br>      +-------------------------------+<br>                     |<br>        +---------------------------+<br>        |   Local Network Protocol  |    Network Level<br>        +---------------------------+<br></pre><br><br>Reliable Communication<li>made available by sequence numbers and acknowledgements</li><li>first octet of data in a segment is called the segment sequence number</li><li>each segment also indicate which is the sequence number of the next expected data octet of transmission in reverse order</li><li>if TCP transmits a segment containing data, it puts a copy on a retransmission queue and starts a timer, if no acknowledgement is received before the timer runs out, the segment is retransmitted.</li><li>window frame helps govern the flow of data between TCPs</li><br><br>Connection Establishment and Clearing<br><br>Unique Identification<li>to seperate data streams, the TCP provides a port id, but that is not unique</li><li>to provide for unique addresses within each TCP, the internet address is concatenated with a port id to create a socket</li><br><br>Full Duplex<li>connection which is used to carry data in both directions</li><br><br>Port Ownership w Processes<li>there are well-known sockets which the TCP associated with "appropriate" processes</li><li>these processes can initiate connections only on the ports they own</li><br><br>Socket Connection<li>connection is specificed in the OPEN call by the local port and the foreign socket arguments</li><li>the TCP provides a connection name by which the users can refer to in subsequent calls</li><li>local connection name will be a pointer to a TCB</li><li>the OPEN call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for</li><br><br>Transmission Control Block (TCB)<li>data structure which holds the information about a connection</li><br><br>Passive OPEN request<li>process wants to accept incoming connection requests rather than attempting to initiate a connection</li><li>a service process that wished to provide services for unknown other processes would issue a passive OPEN request with an unspecified foreign socket</li><br><br>Foreign Sockets<li>foreign socket of all zeros is used to denote an unspecified socket</li><li>unspecified foreign sockets are allowed only on <b>passive OPENs</b>.</li><br><br>Associating a Socket Address with a Standard Service<li>well known sockets are a convenient mechanism for a associating a socket address with a standard service</li><li>"Telnet-Server" rpocess is permanently assigned to a socket and others are reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes</li><li>one might be resevered for a "Look-Up" service to find specific sockets</li><br><br>Active OPEN request<li>processes can issue passive OPENs and wait for matching active OPENs from other processes</li><li>two processes which issue active OPENs to eachother at the same time will be connected</li><br><br>Principal Cases for Matching Sockets<br>1. local passive OPENs has fully specified the foreign socket: match must be exact<br>2. local passive OPENs has left the foreign socket unspecified: any foreign socket is acceptable as long as the local sockets match<li>if several pending passive OPENs are targetting the same local socket, an foreign active OPEN will be matched to a TCB with the specific foreign sockets, if they exist, before selecting a TCB with an unspecified foregin socket</li><br><br>Connection Initiated<li>rendezvous of arriving segment with SYN and a waiting TCB entry each created by a user OPEN command</li><li>matching of local and foregin socket determines which a connection has been initiated</li><li>connection becomes "established" which sequence numbers have been synchronized in both directions</li><br><br>Data Communication<li>data that flows can be thought of as a stream of octets</li><br><br>PUSH Flag<li>determines whether the data sent to a user in a SEND call should be immediately pushed through to the receiving user</li><li>otherwise, a sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience</li><li>does not provide a record service</li><br><br>PUSH flag and Buffers<li>each time a PUSH flag is associated with data placed into the receiving user's buffer, the buffer is returned to the ser for processing even if the buffer is not filled</li><li>if buffer gets filled before a PUSH, data is passed in buffer size units</li><br><br>Hijacking Communication<li>if there is urgent data the TCP provides means to communicate at some point further along in the data stream then the receiver is currently reading</li><br><br>Precedence and Security <li>provided by the internet protocol type of service field and security option</li><br><br>Robustness Principle<li>be conservative in what you do, be liberal in what you accept from others</li><br><br><h2>FUNCTIONAL SPECIFICATION</h2><br><br>Header Format<li>TCP segments are sent as internet datagrams</li><br><pre><br>  0                   1                   2                   3<br>  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |          Source Port          |       Destination Port        |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |                        Sequence Number                        |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |                    Acknowledgment Number                      |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |  Data |           |U|A|P|R|S|F|                               |<br> | Offset| Reserved  |R|C|S|S|Y|I|            Window             |<br> |       |           |G|K|H|T|N|N|                               |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |           Checksum            |         Urgent Pointer        |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |                    Options                    |    Padding    |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br> |                             data                              |<br> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br><br>                          TCP Header Format<br> </pre><li>source port: 16 bits</li><li>destination port: 16 bits</li><li>sequence number: 32 bits (sequence number of the first data octet, unless SYN)</li><li>acknowledgement number: 32 bits (contains values of the next sequence number)</li><li>data offset: 4 bits (indicates where data begins)</li><li>reserved 6 bits (zeros)</li><li>control bits</li><br><pre><br> URG:  Urgent Pointer field significant<br> ACK:  Acknowledgment field significant<br> PSH:  Push Function<br> RST:  Reset the connection<br> SYN:  Synchronize sequence numbers<br> FIN:  No more data from sender<br></pre><li>window: 16 bits</li><li>checksum: 16 bits (one's complement of the one's complement sum of all 16 bit words in the header)</li><br><pre><br> +--------+--------+--------+--------+<br> |           Source Address          |<br> +--------+--------+--------+--------+<br> |         Destination Address       |<br> +--------+--------+--------+--------+<br> |  zero  |  PTCL  |    TCP Length   |<br> +--------+--------+--------+--------+<br></pre><li>urgent pointer: 16 bits (indicates the current value as a +ve offest from the sequence number in this segment)</li><li>options: variable</li><br><pre><br>Case 1:  A single octet of option-kind.<br><br>Case 2:  An octet of option-kind, an octet of option-length, and<br>         the actual option-data octets.<br>Currently defined options include (kind indicated in octal):<br><br> Kind     Length    Meaning<br> ----     ------    -------<br>  0         -       End of option list.<br>  1         -       No-Operation.<br>  2         4       Maximum Segment Size.<br></pre><li>padding: variable (zeros)</li><br><br>Terminology<li>variables stored in the TCB</li><br><pre><br> Send Sequence Variables<br><br>  SND.UNA - send unacknowledged<br>  SND.NXT - send next<br>  SND.WND - send window<br>  SND.UP  - send urgent pointer<br>  SND.WL1 - segment sequence number used for last window update<br>  SND.WL2 - segment acknowledgment number used for last window<br>            update<br>  ISS     - initial send sequence number<br><br>Receive Sequence Variables<br><br>  RCV.NXT - receive next<br>  RCV.WND - receive window<br>  RCV.UP  - receive urgent pointer<br>  IRS     - initial receive sequence number<br><br>Current Segment Variables<br><br> SEG.SEQ - segment sequence number<br> SEG.ACK - segment acknowledgment number<br> SEG.LEN - segment length<br> SEG.WND - segment window<br> SEG.UP  - segment urgent pointer<br> SEG.PRC - segment precedence value<br></pre><br><br>Connection Progression through State-Changes<li>a TCP connection progresses from one state to another in response to events</li><li>events are user calls: OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS, and incoming segments: SYN, ACK, RST, and FIN flags, and timeouts</li><li>LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING. LAST-ACK, TIME-WAIT, and CLOSED (fictional to represent the state where there is no TCB</li><br><pre><br>LISTEN - represents waiting for a connection request from any remote<br>TCP and port.<br><br>SYN-SENT - represents waiting for a matching connection request<br>after having sent a connection request.<br><br>SYN-RECEIVED - represents waiting for a confirming connection<br>request acknowledgment after having both received and sent a<br>connection request.<br><br>ESTABLISHED - represents an open connection, data received can be<br>delivered to the user.  The normal state for the data transfer phase<br>of the connection.<br><br>FIN-WAIT-1 - represents waiting for a connection termination request<br>from the remote TCP, or an acknowledgment of the connection<br>termination request previously sent.<br><br>FIN-WAIT-2 - represents waiting for a connection termination request<br>from the remote TCP.<br><br>CLOSE-WAIT - represents waiting for a connection termination request<br>from the local user.<br><br>CLOSING - represents waiting for a connection termination request<br>acknowledgment from the remote TCP.<br><br>LAST-ACK - represents waiting for an acknowledgment of the<br>connection termination request previously sent to the remote TCP<br>(which includes an acknowledgment of its connection termination<br>request).<br> <br>TIME-WAIT - represents waiting for enough time to pass to be sure<br>the remote TCP received the acknowledgment of its connection<br>termination request.<br><br>CLOSED - represents no connection state at all.<br></pre><br><br>State Diagram (Summary)<br><pre><br>                             +---------+ ---------\      active OPEN<br>                             |  CLOSED |            \    -----------<br>                             +---------+<---------\   \   create TCB<br>                               |     ^              \   \  snd SYN<br>                  passive OPEN |     |   CLOSE        \   \<br>                  ------------ |     | ----------       \   \<br>                   create TCB  |     | delete TCB         \   \<br>                               V     |                      \   \<br>                             +---------+            CLOSE    |    \<br>                             |  LISTEN |          ---------- |     |<br>                             +---------+          delete TCB |     |<br>                  rcv SYN      |     |     SEND              |     |<br>                 -----------   |     |    -------            |     V<br>+---------+      snd SYN,ACK  /       \   snd SYN          +---------+<br>|         |<-----------------           ------------------>|         |<br>|   SYN   |                    rcv SYN                     |   SYN   |<br>|   RCVD  |<-----------------------------------------------|   SENT  |<br>|         |                    snd ACK                     |         |<br>|         |------------------           -------------------|         |<br>+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+<br>  |           --------------   |     |   -----------<br>  |                  x         |     |     snd ACK<br>  |                            V     V<br>  |  CLOSE                   +---------+<br>  | -------                  |  ESTAB  |<br>  | snd FIN                  +---------+<br>  |                   CLOSE    |     |    rcv FIN<br>  V                  -------   |     |    -------<br>+---------+          snd FIN  /       \   snd ACK          +---------+<br>|  FIN    |<-----------------           ------------------>|  CLOSE  |<br>| WAIT-1  |------------------                              |   WAIT  |<br>+---------+          rcv FIN  \                            +---------+<br>  | rcv ACK of FIN   -------   |                            CLOSE  |<br>  | --------------   snd ACK   |                           ------- |<br>  V        x                   V                           snd FIN V<br>+---------+                  +---------+                   +---------+<br>|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|<br>+---------+                  +---------+                   +---------+<br>  |                rcv ACK of FIN |                 rcv ACK of FIN |<br>  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |<br>  |  -------              x       V    ------------        x       V<br>   \ snd ACK                 +---------+delete TCB         +---------+<br>    ------------------------>|TIME WAIT|------------------>| CLOSED  |<br>                             +---------+                   +---------+<br><br>                     TCP Connection State Diagram<br></pre><br><br>Sequence Numbers<li>every octet of data sent over a TCP has a sequence number</li><li>sequence number space is finite (range 0 to 2^23-1) therefore must be % to form a loop with that amount</li><br><br>Sequence Number Comparisons TCP must preform:<br>1. determining that ack refers to some sequence number sent but not acknowledged<br>2. determining that all sequence numbers occupied by a segment have been acknowledged (remove the segment from retransmission queue_<br>3. determining that an incoming segment contains sequence numbers which are expected ("overlaps" the receive window)<br><br>New Acknowledgement<li>"acceptable ack"</li><li>holds this inequality: SND.UNA < SEG.ACK =< SND.NXT</li><br><br>Retransmission Queue<li>a segment is full acknowledged if the sum of its sequence number and the length is less or equal than the acknowledgement value in the incoming segment</li><br><br>When data is received the following comparisons are needed:<br><pre><br>RCV.NXT = next sequence number expected on an incoming segments, and<br>    is the left or lower edge of the receive window<br><br>RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming<br>    segment, and is the right or upper edge of the receive window<br><br>SEG.SEQ = first sequence number occupied by the incoming segment<br><br>SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming<br>    segment<br></pre><br>                    <br>Segment Validity<li>sequence is judged to occupy a valid receive sequence space if:</li><li>RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.W</li><li>first part checks if beginning falls in the window</li><li>second part tests to see if the end falls in the window</li><li>if segment passes either, it contains data in the window</li><br><br>In Reality, with Zero Windows and Zero Lenght Segments<li>we have four cases for acceptability of an incoming segment</li><br><pre><br>Segment Receive  Test<br>Length  Window<br>------- -------  -------------------------------------------<br><br>   0       0     SEG.SEQ = RCV.NXT<br><br>   0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND<br><br>  >0       0     not acceptable<br><br>  >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND<br>              or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND<br></pre><br><br>Note: when the receive window is zero, no segments should be acceptable accept for ACK segments<br><br>Therefore it is possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs, but the TCP must processes the RST and URG fields<br><br>Control Information<li>control information is not physically carried in the segment data space</li><li>SYN and FIN are the only controls requiring implicity assignment of sequence numbers.</li><li>SYN occurs before the first actual data octet</li><li>FIN occurs after the last actual data octet</li><li>SEG.LEN includes both data and sequence space occupying controls</li><br><br>Sequence Number Synchronization<li>each side sends it's own sequence number and acknowledgement</li><li>steps 2, and 3 are combined in a single message.</li><br>1. A --> B  SYN my sequence number is X<br>2. A <-- B  ACK your sequence number is X<br>3. A <-- B  SYN my sequence number is Y<br>4. A --> B  ACK your sequence number is Y<br><br>This is called the <b>Three Way Handshake</b><li>procedure used to establish a connection</li><li>normally initiated by one TCP and responded to by another</li><li>also works if two are requesting simultaneously</li><br><br>Reset Generation (RST)<li>RST nust be sent whenever a segment arrives which is not intended for the current connection</li><br>  <br>Three Groups of States<br>1. connection does not exist (CLOSED), RST is sent in response to any incoming segment except another RST<br>2. connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), the incoming segment acknowledges something not yet sent (unacceptable ACK) with a RST<br>3. connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), any unacceptable segment must elicit only an empty ACK segment containing the current send-sequence number<br><br>Reset Processing<li>in all states except SYN-SENT, all RST segments are validated by checking their SEQ-fields</li><li>RST is valid if its sequence number is in the window</li><li>in a SYN-SENT state, RST is acceptable if the ACK field acknowledges the SYN</li><br><br>Closing the Connection<li>CLOSE means "I have no more data to send"</li><li>closes the full-duplex connection in a simplex fashion</li><li>user who CLOSE may contine to RECEIVE until he is told the other side has CLOSED as well</li><br><br>There are essentially three cases:<br>1. the user initiates by telling the TCP to CLOSE the connection<br>2. the remote TCP initiates by sending a FIN control signal<br>3. both users CLOSE simultaneously<br>
</body>
</html>